THE KEYWORD THIS - JS notes

All functions in JavaScript have properties, just as objects have properties. When
a function executes, it gets the "this" property, which has the value of the object
that invoked the function where "this" is used. It is only given a value when an object
invokes the "this" function.

"this" refers to the instance of an object. When you create an object using the "new"
keyword, you are creating an instance of that type of object.

In most cases, the value of "this" is determined by how a function is called.

//QUESTION if I define a function independently, and then assign it to an object,
and then assign it to another object later, will "this" refer to each object during
each invocation?

If a method is called on an object's prototype chain, it refers to the object the method
was called on, as if the method was on the object.

var o = {f:function(){ return this.a + this.b; }};
var p = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); // 5

When a function is used as a constructor (ie with the "new" keyword), its "this" is
bound to the new object being constructed.

Use of "This" in Global Scope

In the global scope, when the code is executing in the browser, all global variables
and functions are defined on the "window" object. So when we use "this" in a global
function, it refers to (and has the value of) the global "window" object that is
the main container of the entire JavaScript application or web page.

Note: when we use "strict mode", "this" holds the value of "undefined" in global
functions and in anonymous functions that are not bound to any object.

Problem Areas

1. Fix "this" When Used in a Method Passed as a Callback

You can use the Bind() Apply() or Call() methods to fix issues with callbacks.

2. Fix "this" Inside Closure

When using an inner method (a closure) remember that it can't access the outer function's
"this" keyword. "this" is only available to the function itself, not inner functions.

To solve this, set the "this" to another variable before you enter the inner method. ??
A lot of developers use the word "that" when setting a variable for "this." Some
recommend using a more specific name.

3. Fix "this" When Method is Assigned to a Variable

If we assign a method that uses "this" to a variable, it is bound to another object. ??
Fix this with the bind method.

4. Fix "this" When Borrowing Methods

Borrowing methods is common in JavaScript. Borrowing is when a function uses another
function's method. Fix this using the apply method. ??

Apply, Bind, and Call Methods

Where a function uses "this" in its body, its value can be bound to a particular
object in the call by using the apply or call methods that all functions inherit
from the function prototype.

1. Apply

<function>.array(<object, <array with parameter/s>);

or when using a borrowed method:

<function with borrowed method>.<method>.apply(<object borrowing method>, <array of arguments to pass to method>);

2. Call

<function>.call(<object>, <parameter/s>, <parameter/s>);

or when using a borrowed method

<function with borrowed method>.<method>.call(<object borrowing method>, <parameter/s>);

Note: with call and apply, if "this" refers to something other than an object, JavaScript
will attempt to make a new object.

3. Bind

Four Rules For Determining What "this" is Bound to

1. Implicit Binding

2. Explicit Binding
-call
-apply
-bind

3. New Binding

4. Default Binding


LECTURE NOTES

var OrderMethods = {
  calculateTax: function (order, includeLocal, includeFlat) {
    var tax = this.total * 0.10;

    if (includeLocal) {
      tax += this.total * 0.01;
    }

    if (includeFlat) {
    tax += 0.25;
    }

    return tax
  }
}

var order1 = {
  total: 10,
  calculateTax: OrderMethods.calculateTax
}

var order1Tax = order1.calculateTax(); //"this" is order1

Would also work if calculateTax was a function wihtout an object

Implicit Binding

"this" is implicitly bound to the object to the left of the invocation,
by default "this" is implicitly bound to the global window object.

Look at where the method is being called, not where it is being declared.

Implicit binding only happens when you designate the function with "this" as a method of an object

Explicit Binding

Combines syntax of implicit binding, nothing included in the paramaters to the method.
Rather than let javascript decide what to assign it to, we will tell javascript what to assign it to.

Accessing a method on the function named "call."

var OrderMethods = {
  calculateTax: function (order, includeLocal, includeFlat) {
    var tax = this.total * 0.10;

    if (includeLocal) {
      tax += this.total * 0.01;
    }

    if (includeFlat) {
    tax += 0.25;
    }

    return tax
  }
}

var order1 = {
  total: 10
}

order1Tax = calculateTax.call(order1, true, true);
OR
order1Tax = calculateTax.apply(order1, [true, true]);

You're explicitly telling javascript that order1 will be "this." Both of these
act identically, they just accept parameters differently. Apply uses an array
for the parameters.

Sidenote: arguments is a keyword inside of a function that gives you all of the
parameters that were passed to the function as an object.

Bind

Bind does something a little different. It makes a function, so if you want it to
execute you have to invoke it, so you need to assign it to a variable.
It doesn't immediately invoke the function.

function SayHello(p1, p2) {
  console.log("p1: " + p1);
  console.log("p2: " + p1);
  console.log("Hello" + this.name);
}

var person = {name: "Jared"};
sayHello.bind(person); //yields just the function
var reallySayHello = sayHello.bind(person, 'P1'); supply object and parameters(optional)
reallySayHello('P2'); //actually does the console log. fill in extra parameter(optional)
